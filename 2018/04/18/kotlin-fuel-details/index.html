<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
          Kotlin网络库Fuel的设计之道 - 梁飞的博客 | liangfei&#39;s Blog
        
    </title>

    <link rel="canonical" href="http://liangfei.me/2018/04/18/kotlin-fuel-details/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">LIANG.FEI</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archives/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/home-bg.jpg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#Kotlin" title="Kotlin">Kotlin</a>
                        
                          <a class="tag" href="/tags/#Fuel" title="Fuel">Fuel</a>
                        
                    </div>
                    <h1>Kotlin网络库Fuel的设计之道</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        Posted by liangfei on
                        2018-04-18
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>一个“朴素”的 url 完全可以用一个字符串来表示（例如 <code>&quot;http://httpbin.org/get&quot;</code>），我们利用 Kotlin 语言本身的特性为 <code>String</code> 类型添加一个扩展函数 <code>httpGet()</code>，然后借此发起 http 请求：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="string">"http://httpbin.org/get"</span>.httpGet()</span><br></pre></td></tr></table></figure>
<p>但是，对于“不朴素”的字符串来说，我们可以让其实现一个接口：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PathStringConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> path: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将“计算”过后的 path 通过一个 <code>String</code> 类型提供出来，用法如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpsBin</span></span>(relativePath: String) : Fuel.PathStringConvertible &#123;</span><br><span class="line">    USER_AGENT(<span class="string">"user-agent"</span>),</span><br><span class="line">    POST(<span class="string">"post"</span>),</span><br><span class="line">    PUT(<span class="string">"put"</span>),</span><br><span class="line">    PATCH(<span class="string">"patch"</span>),</span><br><span class="line">    DELETE(<span class="string">"delete"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> path = <span class="string">"https://httpbin.org/<span class="variable">$relativePath</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们所有的 url 都有一个 base url，或者是其他公用参数，那么还需有一个地方来存储这些通用配置，而这个地方的幕后老大就叫 <code>FuelManager</code>。<code>String</code> 和 <code>PathStringConvertible</code> 最终也会调用到 <code>FuelManager</code>。</p>
<pre><code>+----------+
|  String  |-------------&gt;----+
+----------+                  |    +------+    +-------------+
                              |---&gt;| Fuel |---&gt;| FuelManager |
+-------------------------+   |    +------+    +-------------+
|  PathStringConvertible  |-&gt;-+
+-------------------------+
</code></pre><p>除了通过 <code>String</code> 或者 <code>PathStringConvertiable</code> 来发起请求，我们还可以直接用一个 <code>Request</code> 变量，因此 <code>Fuel</code> 还提供了转换 <code>Request</code> 的接口：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">RequestConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> request: Request</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上来看，发起一个 http 请求可以有如下四种方式：</p>
<ol>
<li>一个字符串</li>
<li><code>PathStringConvertible</code> 变量</li>
<li><code>RequestConvertible</code> 变量</li>
<li>直接使用 <code>Fuel</code> 伴生对象的方法</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="对外提供服务的-Fuel"><a href="#对外提供服务的-Fuel" class="headerlink" title="对外提供服务的 Fuel"></a>对外提供服务的 Fuel</h3><p>首先 <code>Fuel</code> 作为对外的接口提供方（类似 Facade 模式），通过一个伴生对象（companion object）提供服务（以 get 方法为例）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">  <span class="meta">@JvmStatic</span> <span class="meta">@JvmOverloads</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(path: <span class="type">String</span>, parameters: <span class="type">List</span>&lt;<span class="type">Pair</span>&lt;<span class="type">String</span>, Any?&gt;&gt;? = <span class="literal">null</span>)</span></span>: Request =</span><br><span class="line">          request(Method.GET, path, parameters)</span><br><span class="line"></span><br><span class="line">  <span class="meta">@JvmStatic</span> <span class="meta">@JvmOverloads</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(convertible: <span class="type">PathStringConvertible</span>, parameters: <span class="type">List</span>&lt;<span class="type">Pair</span>&lt;<span class="type">String</span>, Any?&gt;&gt;? = <span class="literal">null</span>)</span></span>: Request =</span><br><span class="line">          request(Method.GET, convertible, parameters)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">request</span><span class="params">(method: <span class="type">Method</span>, path: <span class="type">String</span>, parameters: <span class="type">List</span>&lt;<span class="type">Pair</span>&lt;<span class="type">String</span>, Any?&gt;&gt;? = <span class="literal">null</span>)</span></span>: Request =</span><br><span class="line">          FuelManager.instance.request(method, path, parameters)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">request</span><span class="params">(method: <span class="type">Method</span>, convertible: <span class="type">PathStringConvertible</span>, parameters: <span class="type">List</span>&lt;<span class="type">Pair</span>&lt;<span class="type">String</span>, Any?&gt;&gt;? = <span class="literal">null</span>)</span></span>: Request =</span><br><span class="line">          request(method, convertible.path, parameters)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Fuel 类通过伴生对象提供的 http 方法有 <em>get/post/put/patch/delete/download/upload/head</em>，这些方法最终会路由到 <code>FuleManager</code> 的实例（instance）。</p>
<p>同时，<code>Fule.kt</code> 源文件为 <code>String</code> 和 <code>PathStringConvertible</code> 定义了扩展，以支持这些 http 方法（以 get 方法为例）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JvmOverloads</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">httpGet</span><span class="params">(parameters: <span class="type">List</span>&lt;<span class="type">Pair</span>&lt;<span class="type">String</span>, Any?&gt;&gt;? = <span class="literal">null</span>)</span></span>: Request = Fuel.<span class="keyword">get</span>(<span class="keyword">this</span>, parameters)</span><br><span class="line"></span><br><span class="line"><span class="meta">@JvmOverloads</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Fuel.PathStringConvertible.<span class="title">httpGet</span><span class="params">(parameter: <span class="type">List</span>&lt;<span class="type">Pair</span>&lt;<span class="type">String</span>, Any?&gt;&gt;? = <span class="literal">null</span>)</span></span>: Request = Fuel.<span class="keyword">get</span>(<span class="keyword">this</span>, parameter)</span><br></pre></td></tr></table></figure>
<h3 id="幕后老大-FuleManager"><a href="#幕后老大-FuleManager" class="headerlink" title="幕后老大 FuleManager"></a>幕后老大 FuleManager</h3><p>FuleManager 利用<a href="https://github.com/LyndonChin/kotlin-docs-zh/blob/master/classes-and-objects/10_objects.md#伴生对象" target="_blank" rel="noopener">伴生对象</a>实现了单例模式：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">  <span class="comment">//manager</span></span><br><span class="line">  <span class="keyword">var</span> instance <span class="keyword">by</span> readWriteLazy &#123; FuelManager() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时利用<a href="https://github.com/LyndonChin/kotlin-docs-zh/blob/master/classes-and-objects/12_delegated-properties.md" target="_blank" rel="noopener">代理属性</a>实现了单例的懒加载。</p>
<p><code>readWriteLazy</code> 是一个函数，它的返回值是一个 <code>ReadWriteProperty</code>，代码比较容易，具体可见 <a href="https://github.com/kittinunf/Fuel/blob/master/fuel/src/main/kotlin/com/github/kittinunf/fuel/util/Delegates.kt#L8" target="_blank" rel="noopener">Delegates.kt</a>。</p>
<p>也就是说，当我们第一次访问 <code>FuelManager</code> 时，一个具体的实例会被创建出来，这个实例担负了存储公用配置和发起请求的重任，首先来看它的属性：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> client: Client</span><br><span class="line"><span class="keyword">var</span> proxy: Proxy?</span><br><span class="line"><span class="keyword">var</span> basePath: String?</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baseHeaders: Map&lt;String, String&gt;?</span><br><span class="line"><span class="keyword">var</span> baseParams: List&lt;Pair&lt;String, Any?&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> keystore: KeyStore?</span><br><span class="line"><span class="keyword">var</span> socketFactory: SSLSocketFactory</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hostnameVerifier: HostnameVerifier</span><br></pre></td></tr></table></figure>
<p><code>Client</code> 是一个接口，通过它我们可以自定义 http 引擎。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">executeRequest</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>+---------+     +--------+     +----------+
| Request | ==&gt; | Client | ==&gt; | Response |
+---------+     +--------+     +----------+
                     |
                    \|/                   +--------------------+
              +------------+              | HttpURLConnection  |
              | HttpClient | --based on-- +--------------------+
              +------------+              | HttpsURLConnection |
                                          +--------------------+
</code></pre><p>Fuel 默认提供的 Http 引擎是 <code>HttpClient</code>，它是基于 HttpURLConnection 实现。</p>
<p><code>basePath</code>、<code>baseHeaders</code> 和 <code>baseParams</code> 存储了请求的公用配置，我们可以通过 <code>FuleManager.instance</code> 为其赋值：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">FuelManager.instance.apply &#123;</span><br><span class="line">  basePath = <span class="string">"http://httpbin.org"</span></span><br><span class="line">  baseHeaders = mapOf(<span class="string">"Device"</span> to <span class="string">"Android"</span>)</span><br><span class="line">  baseParams = listOf(<span class="string">"key"</span> to <span class="string">"value"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>keystore</code> 用于构建 <code>socketFactory</code>，再加上 <code>hostnameVerifier</code>，它们用于 https 请求，在 <code>HttpClient</code> 中有用到：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">establishConnection</span><span class="params">(request: <span class="type">Request</span>)</span></span>: URLConnection &#123;</span><br><span class="line">  <span class="keyword">val</span> urlConnection = <span class="keyword">if</span> (proxy != <span class="literal">null</span>) request.url.openConnection(proxy) <span class="keyword">else</span> request.url.openConnection()</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">if</span> (request.url.protocol == <span class="string">"https"</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> conn = urlConnection <span class="keyword">as</span> HttpsURLConnection</span><br><span class="line">    conn.apply &#123;</span><br><span class="line">      sslSocketFactory = request.socketFactory <span class="comment">// socketFactory</span></span><br><span class="line">      hostnameVerifier = request.hostnameVerifier <span class="comment">// hostnameVerifier</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    urlConnection <span class="keyword">as</span> HttpURLConnection</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>如果要深入了解 HTTPS 证书，可参考 「<a href="https://zhuanlan.zhihu.com/p/30655259" target="_blank" rel="noopener">HTTPS 精读之 TLS 证书校验</a>」。</em></p>
<p>FuelManager 在发起请求时会用这些参数构建一个 <code>Request</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">request</span><span class="params">(method: <span class="type">Method</span>, path: <span class="type">String</span>, param: <span class="type">List</span>&lt;<span class="type">Pair</span>&lt;<span class="type">String</span>, Any?&gt;&gt;? = <span class="literal">null</span>)</span></span>: Request &#123;</span><br><span class="line">  <span class="keyword">val</span> request = request(Encoding(</span><br><span class="line">        httpMethod = method,</span><br><span class="line">        urlString = path,</span><br><span class="line">        baseUrlString = basePath,</span><br><span class="line">        parameters = <span class="keyword">if</span> (param == <span class="literal">null</span>) baseParams <span class="keyword">else</span> baseParams + param</span><br><span class="line">  ).request)</span><br><span class="line"></span><br><span class="line">  request.client = client</span><br><span class="line">  request.headers += baseHeaders.orEmpty()</span><br><span class="line">  request.socketFactory = socketFactory</span><br><span class="line">  request.hostnameVerifier = hostnameVerifier</span><br><span class="line">  request.executor = createExecutor()</span><br><span class="line">  request.callbackExecutor = callbackExecutor</span><br><span class="line">  request.requestInterceptor = requestInterceptors.foldRight(&#123; r: Request -&gt; r &#125;) &#123; f, acc -&gt; f(acc) &#125;</span><br><span class="line">  request.responseInterceptor = responseInterceptors.foldRight(&#123; _: Request, res: Response -&gt; res &#125;) &#123; f, acc -&gt; f(acc) &#125;</span><br><span class="line">  <span class="keyword">return</span> request</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 <code>requestInterceptor</code> 和 <code>responseInterceptor</code>，原理与 OkHttp 实现的拦截器一致，只不过这里利用了 Kotlin 的高阶函数，代码实现非常简单，具体细节可参考 「<a href="http://liangfei.me/2018/04/10/kotlin-fuel-interceptor/">Kotlin实战之Fuel的高阶函数</a>」。</p>
<p>跟其他网络库一样，一次完整的请求，必然包含两个实体—— <code>Request</code> &amp; <code>Response</code>，先来看 <code>Request</code>。</p>
<h3 id="请求实体-Request"><a href="#请求实体-Request" class="headerlink" title="请求实体 Request"></a>请求实体 Request</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span></span>(</span><br><span class="line">  <span class="keyword">val</span> method: Method,</span><br><span class="line">  <span class="keyword">val</span> path: String,</span><br><span class="line">  <span class="keyword">val</span> url: URL,</span><br><span class="line">  <span class="keyword">var</span> type: Type = Type.REQUEST,</span><br><span class="line">  <span class="keyword">val</span> headers: MutableMap&lt;String, String&gt; = mutableMapOf(),</span><br><span class="line">  <span class="keyword">val</span> parameters: List&lt;Pair&lt;String, Any?&gt;&gt; = listOf(),</span><br><span class="line">  <span class="keyword">var</span> name: String = <span class="string">""</span>,</span><br><span class="line">  <span class="keyword">val</span> names: MutableList&lt;String&gt; = mutableListOf(),</span><br><span class="line">  <span class="keyword">val</span> mediaTypes: MutableList&lt;String&gt; = mutableListOf(),</span><br><span class="line">  <span class="keyword">var</span> timeoutInMillisecond: <span class="built_in">Int</span> = <span class="number">15000</span>,</span><br><span class="line">  <span class="keyword">var</span> timeoutReadInMillisecond: <span class="built_in">Int</span> = timeoutInMillisecond) : Fuel.RequestConvertible</span><br></pre></td></tr></table></figure>
<p>它支持三种类型的请求：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">  REQUEST,</span><br><span class="line">  DOWNLOAD,</span><br><span class="line">  UPLOAD</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对每个类型都有对应的任务（task）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//underlying task request</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">val</span> taskRequest: TaskRequest <span class="keyword">by</span> lazy &#123;</span><br><span class="line">  <span class="keyword">when</span> (type) &#123;</span><br><span class="line">    Type.DOWNLOAD -&gt; DownloadTaskRequest(<span class="keyword">this</span>)</span><br><span class="line">    Type.UPLOAD -&gt; UploadTaskRequest(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; TaskRequest(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>涉及到上传下载的 <code>DownloadTaskRequest</code> 和 <code>UploadTaskRequest</code> 都继承自 <code>TaskRequest</code>，它们会处理文件和流相关的东西，关于此可参考 IO 哥写的 <a href="https://zhuanlan.zhihu.com/p/35518932" target="_blank" rel="noopener">一些「流与管道」的小事</a> 以及 <a href="https://zhuanlan.zhihu.com/p/35807478" target="_blank" rel="noopener">OK, IO</a>。</p>
<p><code>FuelManager</code> 在构造 <code>Request</code> 时用到了一个类 <code>Encoding</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Encoding</span></span>(</span><br><span class="line">  <span class="keyword">val</span> httpMethod: Method,</span><br><span class="line">  <span class="keyword">val</span> urlString: String,</span><br><span class="line">  <span class="keyword">val</span> requestType: Request.Type = Request.Type.REQUEST,</span><br><span class="line">  <span class="keyword">val</span> baseUrlString: String? = <span class="literal">null</span>,</span><br><span class="line">  <span class="keyword">val</span> parameters: List&lt;Pair&lt;String, Any?&gt;&gt;? = <span class="literal">null</span>) : Fuel.RequestConvertible</span><br></pre></td></tr></table></figure>
<p><code>Encoding</code> 也是继承自 <code>Fuel.RequestConvertible</code>，它完成了对 <code>Request</code> 参数的组装编码，并产生了一个 <code>Request</code>。<code>Encoding</code> 组装 query parameter 的方式可以说赏心悦目，贴出来欣赏一下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">queryFromParameters</span><span class="params">(params: <span class="type">List</span>&lt;<span class="type">Pair</span>&lt;<span class="type">String</span>, Any?&gt;&gt;?)</span></span>: String = params.orEmpty()</span><br><span class="line">  .filterNot &#123; it.second == <span class="literal">null</span> &#125;</span><br><span class="line">  .map &#123; (key, value) -&gt;  URLEncoder.encode(key, <span class="string">"UTF-8"</span>) to URLEncoder.encode(<span class="string">"<span class="variable">$value</span>"</span>, <span class="string">"UTF-8"</span>) &#125;</span><br><span class="line">  .joinToString(<span class="string">"&amp;"</span>) &#123; (key, value) -&gt; <span class="string">"<span class="variable">$key</span>=<span class="variable">$value</span>"</span> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="请求返回结果-Response"><a href="#请求返回结果-Response" class="headerlink" title="请求返回结果 Response"></a>请求返回结果 Response</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Response</span></span>(</span><br><span class="line">  <span class="keyword">val</span> url: URL,</span><br><span class="line">  <span class="keyword">val</span> statusCode: <span class="built_in">Int</span> = <span class="number">-1</span>,</span><br><span class="line">  <span class="keyword">val</span> responseMessage: String = <span class="string">""</span>,</span><br><span class="line">  <span class="keyword">val</span> headers: Map&lt;String, List&lt;String&gt;&gt; = emptyMap(),</span><br><span class="line">  <span class="keyword">val</span> contentLength: <span class="built_in">Long</span> = <span class="number">0</span>L,</span><br><span class="line">  <span class="keyword">val</span> dataStream: InputStream = ByteArrayInputStream(ByteArray(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>由 <code>Response</code> 的属性可以看出，它所携带的仍然是一个流（Stream），在分析反序列化之前，我们先看 <code>Response</code> 是如何与 <code>Request</code> 串联起来的。</p>
<p><code>Deserializable.kt</code> 文件为 <code>Request</code> 定了名称为 <code>response</code> 的扩展函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any, U : Deserializable&lt;T&gt;</span>&gt; Request.<span class="title">response</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  deserializable: <span class="type">U</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  success: (<span class="type">Request</span>, Response, T)</span></span> -&gt; <span class="built_in">Unit</span>,</span><br><span class="line">  failure: (Request, Response, FuelError) -&gt; <span class="built_in">Unit</span>): Request &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> asyncRequest = AsyncTaskRequest(taskRequest)</span><br><span class="line"></span><br><span class="line">    asyncRequest.successCallback = &#123; response -&gt;</span><br><span class="line">      <span class="keyword">val</span> deliverable = Result.of &#123; deserializable.deserialize(response) &#125;</span><br><span class="line">      callback &#123;</span><br><span class="line">        deliverable.fold(&#123;</span><br><span class="line">          success(<span class="keyword">this</span>, response, it)</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">          failure(<span class="keyword">this</span>, response, FuelError(it))</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    asyncRequest.failureCallback = &#123; error, response -&gt;</span><br><span class="line">      callback &#123;</span><br><span class="line">        failure(<span class="keyword">this</span>, response, error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    submit(asyncRequest)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩展函数 <code>response</code> 的参数中，<code>deserializable</code> 反序列化操作，<code>success</code> 和 <code>failure</code> 用于处理请求结果。</p>
<p>Fuel 提供了两个 <code>Deserializable</code> 的实现：<code>StringDeserializer</code> 以及 <code>ByteArrayDeserializer</code>，它们用于反序列化一个 response stream。</p>
<h3 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h3><p><code>Deserializable.kt</code> 为 <code>Request</code> 定义的扩展函数 <code>response</code> 在执行异步操作时用到了一个 <code>AsnycTaskRequest</code>，其实它本身并不提供异步实现，而是交由一个 <code>ExecutorService</code> 去执行，而这个 <code>ExecutorService</code> 恰由 <code>FuelManager</code> 定义，并在构造 <code>Request</code> 时传入给它。</p>
<p>FuleManager.kt<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//background executor</span></span><br><span class="line"><span class="keyword">var</span> executor: ExecutorService <span class="keyword">by</span> readWriteLazy &#123;</span><br><span class="line">  Executors.newCachedThreadPool &#123; command -&gt;</span><br><span class="line">    Thread(command).also &#123; thread -&gt;</span><br><span class="line">      thread.priority = Thread.NORM_PRIORITY</span><br><span class="line">      thread.isDaemon = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>AsyncTaskRequest</code> 和 <code>UploadTaskRequest</code>、<code>DownloadTaskRequest</code> 一样，都是继承自 <code>TaskRequest</code>，只不过它多了两个异步调用的回调：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> successCallback: ((Response) -&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> failureCallback: ((FuelError, Response) -&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<h2 id="请求图例"><a href="#请求图例" class="headerlink" title="请求图例"></a>请求图例</h2><p>至此，请求、回复，异步调用，对外接口都了解过了，一个基本的网络库框架已经成型。</p>
<pre><code>         +------------------------+
         | https://www.youzan.com |
         +------------------------+
                     |
                     |
                    \|/
                  +------+
                  | Fuel |
                  +------+
                     |
                     |
                    \|/
              +-------------+
              | FuelManager |
              +-------------+
                     |
                     |
                    \|/
+---------+      +--------+      +----------+
| Request | ===&gt; | Client | ===&gt; | Response |
+---------+      +--------+      +----------+
</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/35518932" target="_blank" rel="noopener">一些「流与管道」的小事</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/35807478" target="_blank" rel="noopener">OK，IO</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/30655259" target="_blank" rel="noopener">HTTPS 精读之 TLS 证书校验</a></li>
<li><a href="https://github.com/LyndonChin/kotlin-docs-zh" target="_blank" rel="noopener">Kotlin 官方中文教程</a></li>
</ul>


                <hr>

                <div style="text-align: center;">
                    <p>欢迎扫码关注 <b>老梁写代码</b> 微信公众号</p>
                    <img src="https://wx2.sinaimg.cn/mw690/63934de3gy1fpdr77kb6kj209k09kjrc.jpg"/>
                </div>
                <ul class="pager">
                    
                    
                        <li class="next">
                            <a href="/2018/04/10/kotlin-fuel-interceptor/" data-toggle="tooltip" data-placement="top" title="Kotlin实战之Fuel的高阶函数">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

            </div>
    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#Kotlin" title="Kotlin">Kotlin</a>
                        
                          <a class="tag" href="/tags/#Fuel" title="Fuel">Fuel</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="http://yifeiyuan.me/" target="_blank">程序亦非猿</a></li>
                    
                        <li><a href="https://www.liaohuqiu.net/" target="_blank">秋百万</a></li>
                    
                        <li><a href="http://blog.zhaiyifan.cn/" target="_blank">大帅</a></li>
                    
                </ul>
                
            </div>

        </div>
    </div>
</article>


<script type="text/javascript">
/* * * CONFIGURATION VARIABLES * * */
var disqus_shortname = "http-www-liangfei-me";
var disqus_identifier = "http://liangfei.me/2018/04/18/kotlin-fuel-details/";
var disqus_url = "http://liangfei.me/2018/04/18/kotlin-fuel-details/";

var disqus_config = function () {
this.page.url = disqus_url;
this.page.identifier = disqus_identifier;
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://' + disqus_shortname +'.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/liangfei.me">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/liangfeizc">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank"  href="https://github.com/LyndonChin">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; LIANG.FEI 2018 
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> 
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://liangfei.me/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Global site tag (gtag.js) - Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-111924601-1"></script>
    <script>
        var _gaId = 'UA-111924601-1';

        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', _gaId);
    </script>


<!-- Baidu Tongji -->

<script>
    var _baId = '03812d0423cc43c7d86d65fd5bd22176';

    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>


<!-- Side Catalog -->




</body>

</html>
