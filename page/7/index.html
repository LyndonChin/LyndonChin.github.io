<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 7 页 | 梁飞</title>
  <meta name="author" content="liangfei">
  
  <meta name="description" content="梁飞的个人博客">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="梁飞"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="梁飞" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">梁飞</a></h1>
  <h2><a href="/">行有不得反求诸己</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/about">About</a></li>
    
    <li><a href="https://github.com/lyndonchin">Github</a></li>
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-05-04T16:00:00.000Z"><a href="/2015/05/05/introduction-to-sky/">2015-05-05</a></time>
      
      
  
    <h1 class="title"><a href="/2015/05/05/introduction-to-sky/">Dart更近一步，Sky会一统江湖吗？</a></h1>
  

    </header>
    <div class="entry">
      
        <p>从接触编程到现在，除了搞过几天JQuery，几乎没怎么写过Javascript，刚刚看了两篇介绍 ECMAScript6 的文章，突然觉得没写过JS也没什么好遗憾的。</p>
<ul>
<li><a href="https://hacks.mozilla.org/2015/04/es6-in-depth-an-introduction/" target="_blank" rel="external">ES6 In Depth: An Introduction</a></li>
<li><a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/" target="_blank" rel="external">ES6 In Depth: Iterators and the for-of loop</a></li>
</ul>
<p>ES6 好像从2009年就开始制定了，现在终于支持 <code>forEach</code>、<code>for-in</code>等操作，也支持<code>Map</code>、<code>Set</code>等数据类型，而且为了考虑兼容性问题居然引入了一个 <code>for-of</code>，不过看到 <a href="http://githut.info/" target="_blank" rel="external">Githut</a> 上关于 github 语言的统计数据，不得不佩服JS社区强大的生产力。</p>
<p>话说回来，Dart 作为一个崭新的语言，自诞生那天起就抛去了向下兼容的历史包袱，而且可以直接转成 Javascript，Chrome 的 V8 团队还专门为 Dart 做了一个虚拟机 - Dartium。</p>
<p>Dart 目的跟 Node 一样，也是为了统一前后端开发，这一点在上一篇文章 （<a href="http://blog.csdn.net/feelang/article/details/45469151" target="_blank" rel="external">Dart是一个怎样的语言？</a> ）已经说过了，所以用 Dart 做 web 开发也没有额外的学习成本，当然前提是你得会写 Dart。</p>
<p>官方教程提供的一个简单的 web 开发教程 - <a href="https://www.dartlang.org/codelabs/darrrt/" target="_blank" rel="external">Avast, Ye Pirates: Write a Web App</a>，用<code>DartEditor</code>导入后，工程结构如下图所示：</p>
<p><img width="50%" src="http://img.blog.csdn.net/20150504224927710"></p>
<p>有css，有html，一个最简单的web工程（没有后端），在 <code>DartEditor</code> 中可以用两种方式来运行这个工程。</p>
<p><img width="50%" src="http://img.blog.csdn.net/20150504225320675"></p>
<p>如果选择了 <code>Dartium</code>，编译成功后会唤起一个使用了 Dartium 引擎的 chrome 浏览器，而过选择了 <code>Run as JavaScript</code> 就会先把 dart 编译成 js 的工程（工程结构图中灰色的部分），然后唤起一个使用了 V8 引擎的 chrome 浏览器。</p>
<p>其实用 Dart 做开发还是挺方便的，js 都是可以直接拿来用的，但是社区不成熟，不像 node 社区那样有那么多的库。</p>
<hr>
<p>我们再来看看下一代 Android 开发框架 - <a href="https://github.com/domokit" target="_blank" rel="external">sky</a>，今天照着 readme 玩了一下官方提供的几个demo，流畅度可以跟 native 媲美，但是需要从网络加载代码，所以启动时间比较慢，毕竟只是一个实验版本，像 react-native 那样做个本地缓存也不会有什么问题。</p>
<p>整个开发过程与上面的 web 开发非常相似，只不过代码文件的后缀名换了而已。</p>
<p>首先需要创建一个 <code>pubspec.yaml</code>，类似于 Node 的 <code>package.json</code> 或者 gradle 脚本的 <code>build.gradle</code>，主要是一些包依赖关系和 APP 的基本信息，最后一行表示依赖最新版本的 sky。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">name:</span> your_app_name</div><div class="line"><span class="attr">dependencies:</span></div><div class="line"><span class="attr"> sky:</span> any</div></pre></td></tr></table></figure>
<p>在当前目录下执行 <code>pub get</code>，会根据 <code>pubspec.yaml</code> 的依赖配置获取 APP 所依赖的包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">➜  widgets git:(master) ✗ pub get</div><div class="line">Resolving dependencies... (1.7s)</div><div class="line">+ mojo 0.0.5+dart-summit-1</div><div class="line">+ sky 0.0.5+dart-summit-7</div><div class="line">Changed 2 dependencies!</div><div class="line">➜  widgets git:(master) ✗</div></pre></td></tr></table></figure>
<p>执行完毕后会发现在本地多了一个 <code>package</code> 文件夹，里面有刚刚下载的两个包。</p>
<p><img src="http://img.blog.csdn.net/20150505003910350" alt="这里写图片描述"></p>
<p><em>pub会首先把下载来的包缓存到本地，如果有的新的下载可以直接引用之前下载过的包。</em></p>
<p>sky 我们都知道了，它就是 Android 全新的开发框架，由两部分组成：</p>
<pre>
<i>The Sky engine</i>. The engine is the core of the system. Written in C++, the engine provides the muscle of the Sky system. The engine provides several primitives, including a soft real-time scheduler and a hierarchial, retained-mode graphics system, that let you build high-quality apps.

<i>The Sky framework</i>. The framework makes it easy to build apps using Sky by providing familiar user interface widgets, such as buttons, infinite lists, and animations, on top of the engine using Dart. These extensible components follow a functional programming style inspired by React.
</pre>

<p>简单来说，<em>Sky engine</em> 是一个图形系统，VDOM 的创建和diff应该也是它负责的，而 <em>Sky framework</em> 则是一个UI库，提供了我们创建 VDOM 时所需的节点元素。</p>
<p>那 mojo 又是什么呢？</p>
<pre>Mojo is an effort to extract a common platform out of Chrome's renderer and plugin processes that can support multiple types of sandboxed content, such as HTML, Pepper, or NaCl.</pre>

<p>简单来说，mojo 就是 sky 的运行时环境，但是 domokit 下还有一个<a href="https://github.com/domokit/mojo_sdk" target="_blank" rel="external">mojo-sdk</a>，这个 sdk 为我们提供给了基于 mojo 做二次开发所用到的 API。</p>
<pre>The Mojo Public API is a binary stable API to the Mojo system.</pre>

<p>它支持很多种语言，目前为止包括 <code>C</code>、<code>CPP</code>、<code>Dart</code>、<code>Go</code>、<code>Java</code>、<code>js</code>。</p>
<p>也就是说，Google 想打造的是这样一个生态系统。</p>
<img src="/2015/05/05/introduction-to-sky/dart.png" alt="sky framework" title="sky framework">
<hr>
<p>如果这个愿景能够实现，120fps的卖点也许会一统江湖，但是 Google IO 2015 根本没有提及这个项目，希望 Google 不是玩票 :(</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-05-03T16:00:00.000Z"><a href="/2015/05/04/introduction-to-dart/">2015-05-04</a></time>
      
      
  
    <h1 class="title"><a href="/2015/05/04/introduction-to-dart/">Dart 是一个怎样的语言</a></h1>
  

    </header>
    <div class="entry">
      
        <p>这几天看到一篇新闻 - <a href="http://36kr.com/p/532461.html" target="_blank" rel="external">白兼容了？Google 正在为 Android 准备一个去 Java 化的 Dart 应用运行框架</a>，对与新闻的标题和内容无力吐槽，不做评论。但是Google推出 <a href="https://github.com/domokit/sky_sdk" target="_blank" rel="external">sky</a> 似乎证明了native的开发方式越来越向web方式靠近的趋势，最近比较火的要数 <a href="https://github.com/facebook/react-native" target="_blank" rel="external">react-native</a> 了，他们的原理是类似的，都是先构造一个 <em>virtual dom tree</em>，然后只更新发生变化的 dom。sky 的 readme 也说自己参考了 <a href="https://github.com/facebook/react" target="_blank" rel="external">react</a>，那两者最大的区别应该是开发语言了，react-native 是 javascript，而 Google 用的是自己的亲儿子 - <a href="https://www.dartlang.org/" target="_blank" rel="external">Dart</a>。</p>
<p><img src="http://img.blog.csdn.net/20150504004814626" alt="The Sky framework"></p>
<p>Node.js 推出后统一了前后端，如今 node 开发真可谓炙手可热。Google 当初推出 Dart 也是为了统一前后端开发，但是这两年一直不温不火，好像国内使用 <a href="https://github.com/Polymer/polymer" target="_blank" rel="external">Polymer</a> 的开发者也不多，现在用 突然宣布说用 Dart 替换 Android 的开发语言 java，而且还举办了第一个第一届 <a href="https://www.dartlang.org/events/2015/summit/" target="_blank" rel="external">Dart Developer Summit</a>，看来 Google 准备在 Dart 上发力了，相信 Dart 会是五月底 Google IO 大会上的一个重要议题。<br>趁着今天放假，跟着 <a href="https://www.dartlang.org/codelabs/darrrt/" target="_blank" rel="external">Dart 官网的教程</a>玩了一下 Dart，发现 Dart 这门语言确实不错。</p>
<hr>
<h2 id="引用包"><a href="#引用包" class="headerlink" title="引用包"></a>引用包</h2><p>包的引用方式与 Python 和 Go 类似，都是用 <code>import</code>：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">'dart:html'</span>;</div></pre></td></tr></table></figure></p>
<p>不过只导入包的某个组件的方式比较特殊：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">'dart:math'</span> show Random;</div><div class="line"><span class="keyword">import</span> <span class="string">'dart:convert'</span> show JSON;</div><div class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span> show Future;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><s>Dart 与 Python 一样是一个强类型语言</s>。</p>
<p>Dart 的变量类型是可选的，叫做 static type annotations。</p>
<pre>
Dart’s optional types are static type annotations that act as documentation, clearly expressing your intent.
</pre>

<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> Random indexGen = <span class="keyword">new</span> Random();</div><div class="line"><span class="built_in">String</span> _firstName;</div><div class="line"><span class="built_in">String</span> _appellation;</div></pre></td></tr></table></figure>
<p>Dart 没有 <code>private</code> 关键字，如果变量或方法是私有类型，需要在名称前面加上下划线。</p>
<p><strong>私有变量</strong><br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PirateName</span> </span>&#123;</div><div class="line">  # ...</div><div class="line">  <span class="built_in">String</span> _firstName;</div><div class="line">  <span class="built_in">String</span> _appellation;</div><div class="line">  # ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>私有方法</strong><br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> _parsePirateNamesFromJSON(<span class="built_in">String</span> jsonString) &#123;</div><div class="line">  <span class="built_in">Map</span> pirateNames = JSON.decode(jsonString);</div><div class="line">  names = pirateNames[<span class="string">'names'</span>];</div><div class="line">  appellations = pirateNames[<span class="string">'appellations'</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>Dart 用关键字 <code>as</code> 来做类型转换。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> updateBadge(Event e) &#123;</div><div class="line">  <span class="built_in">String</span> inputName = (e.target <span class="keyword">as</span> InputElement).value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>对于某些特定方法，Dart 提供了语法糖，写法很简单。例如，表达式的值即为返回值的情况，可以这么写：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span> toString() =&gt; pirateName;</div></pre></td></tr></table></figure>
<p>不用写成这样：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span> toString() &#123;</div><div class="line">  <span class="keyword">return</span> pirateName;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果是 <code>get</code> 方法，可以直接在返回值类型和方法名之间加上一个关键词 <code>get</code>，而且方法名不需要加括号，调用的时候也不需要加括号。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span> <span class="keyword">get</span> jsonString =&gt; JSON.encode(&#123;<span class="string">"f"</span>: _firstName, <span class="string">"a"</span>: _appellation&#125;);</div><div class="line"></div><div class="line"><span class="built_in">String</span> <span class="keyword">get</span> pirateName =&gt;</div><div class="line">    _firstName.isEmpty ? <span class="string">''</span> : <span class="string">'$_firstName the $_appellation'</span>;</div></pre></td></tr></table></figure>
<hr>
<h2 id="级联操作符（-）"><a href="#级联操作符（-）" class="headerlink" title="级联操作符（..）"></a>级联操作符（..）</h2><p>级联操作符（<em>The cascade operator (..)</em>）可以允许在一个成员变量上执行多个操作。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">genButton..disabled = <span class="keyword">false</span></div><div class="line">         ..text = <span class="string">'Aye! Gimme a name!'</span>;</div></pre></td></tr></table></figure>
<p>以上语句就等价于<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">genButton.disabled = <span class="keyword">false</span>;</div><div class="line">genButton.text = <span class="string">'Aye! Gimme a name!'</span>;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h2><p>Dart 中变量转化成字符串比 Java 方便多了，跟 Python 有一拼，直接在变量名前加上$符号就可以了。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'$_firstName the $_appellation'</span>;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>Dart 支持有名字的构造方法，这一点比 Java 和 Python 都先进。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">PirateName.fromJSON(String jsonString) &#123;</div><div class="line">  Map storedName = JSON.decode(jsonString);</div><div class="line">  _firstName = storedName[&apos;f&apos;];</div><div class="line">  _appellation = storedName[&apos;a&apos;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里 <code>PirateName.fromJSON</code> 是一个整体，用的时候要写全了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return new PirateName.fromJSON(storedName);</div></pre></td></tr></table></figure>
<hr>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>跟 Python 一样，Dart 也支持 <em><a href="http://www.diveintopython.net/power_of_introspection/optional_arguments.html" target="_blank" rel="external">Optional and Named Arguments</a></em>，例如参数可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PirateName(&#123;String firstName, String appellation&#125;) &#123;</div><div class="line">  # ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数要用一个大括号括起来，应该是需要把参数封装成一个类似于 Python 的 <code>Dictionary</code>。</p>
<p>但是调用的时候不需要传递所有的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new PirateName(firstName: inputName)</div></pre></td></tr></table></figure>
<hr>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>Dart 支持泛型，这点跟 Java 很像，例如要定义一个 <code>List</code> 变量可以写成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">static List names = [];</div><div class="line">static List appellations = [];</div></pre></td></tr></table></figure>
<p>如果要写明类型，就需要在 <code>List</code> 后的简括后内加上类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">static List&lt;String&gt; names = [];</div><div class="line">static List&lt;String&gt; appellations = [];</div></pre></td></tr></table></figure></p>
<p>关于泛型类型是否像 java 那样支持 <code>super</code>、 <code>extend</code>还没看到，暂时不知道。</p>
<hr>
<h2 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h2><p>Dart 语言原生支持异步操作，主要是用两个关键词 <code>await</code> 和 <code>async</code>。<br>例如，如果我们要定义一个异步方法，不需要像 java 那样去 <strong>new Thread</strong>，直接在方法后面加上 <code>async</code> 关键字就OK了，这样调用时，该方法时会直接返回一个 <code>Future</code>，caller 无需等待。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static Future readyThePirates() async &#123;</div><div class="line">  String path = &apos;piratenames.json&apos;;</div><div class="line">  String jsonString = await HttpRequest.getString(path);</div><div class="line">  _parsePirateNamesFromJSON(jsonString);    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>await</code> 跟 java中的 wait 方法用法一样，表示等待，但是它只能用于 <code>async</code> 的方法中。</p>
<p>例如上面代码片段中， <code>await HttpRequest.getString(path)</code> 就表示必须要等到 <code>HttpRequest.getString(path)</code> 返回的 <code>Future</code> 有了最终结果才会继续往下执行 <code>_parsePirateNamesFromJSON(jsonString);</code>。</p>
<hr>
<p>不知道 Dart 支不支持一些高大上的语言特性，比如 闭包（Closure）、Lambda表达式（Lambda expression）、生成器（Generator）等，期待后续的学习。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-10-18T16:00:00.000Z"><a href="/2014/10/19/byte-code-on-try-catch/">2014-10-19</a></time>
      
      
  
    <h1 class="title"><a href="/2014/10/19/byte-code-on-try-catch/">用 bytecode 来看 try-catch-finally 和 return</a></h1>
  

    </header>
    <div class="entry">
      
        <p>最近一直在看Java虚拟机规范，发现直接分析bytecode更能加深对Java语言的理解。<br>之前看过一篇关于 <code>return</code> 和 <code>finally</code> 执行顺序的文章，仅在 Java 的语言层面做了分析，其实我倒觉得直接看 bytecode 可能来的更清晰一点。</p>
<p>先看一个只有 <code>try-finally</code>，没有 <code>catch</code> 的例子。</p>
<p><strong>try - finally</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTest</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryFinally</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      tryItOut();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      wrapItUp();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// auxiliary methods</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryItOut</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrapItUp</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过 <code>javap -c ExceptionTest</code> 来查看它的字节码。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void tryFinally();</div><div class="line">  Code:</div><div class="line">     0: aload_0</div><div class="line">     1: invokevirtual #2  // Method tryItOut:()V</div><div class="line">     4: aload_0</div><div class="line">     5: invokevirtual #3  // Method wrapItUp:()V</div><div class="line">     8: goto          18</div><div class="line">    11: astore_1</div><div class="line">    12: aload_0</div><div class="line">    13: invokevirtual #3  // Method wrapItUp:()V</div><div class="line">    16: aload_1</div><div class="line">    17: athrow</div><div class="line">    18: return</div><div class="line">  Exception table:</div><div class="line">     from    to  target type</div><div class="line">         0     4    11   any</div></pre></td></tr></table></figure>
<p>如果没有抛出异常，那么它的执行顺序为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0: aload_0</div><div class="line">1: invokevirtual #2  // Method tryItOut:()V</div><div class="line">4: aload_0</div><div class="line">5: invokevirtual #3  // Method wrapItUp:()V</div><div class="line">18: return</div></pre></td></tr></table></figure>
<p>如果抛出了异常，JVM 会在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Exception table:</div><div class="line">   from    to  target type</div><div class="line">       0     4    11   any</div></pre></td></tr></table></figure>
<p>中进行控制跳转。如果是位于0到4字节之间的命令抛出了任何类型（any type）的异常，会跳转到11字节处继续运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">11: astore_1</div><div class="line">12: aload_0</div><div class="line">13: invokevirtual #3</div><div class="line">16: aload_1</div><div class="line">17: athrow</div></pre></td></tr></table></figure>
<p>astore_1会把抛出的异常对象保存到local variable数组的第二个元素。下面两行指令用来调用成员方法wrapItUp。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">12: aload_0</div><div class="line">13: invokevirtual #3</div></pre></td></tr></table></figure>
<p>最后通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">16: aload_1</div><div class="line">17: athrow</div></pre></td></tr></table></figure>
<p>重新抛出异常。</p>
<p>通过以上分析可以得出结论：</p>
<blockquote>
<p>在try-finally中，try块中抛出的异常会首先保存在local variable中，然后执行finally块，执行完毕后重新抛出异常。</p>
</blockquote>
<p>如果我们把代码修改一下，在try块中直接return。</p>
<p><strong>try - return - finally</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryFinally</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    tryItOut();</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    wrapItUp();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>”反汇编“一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> 0: aload_0</div><div class="line"> 1: invokevirtual #2 // Method tryItOut:()V</div><div class="line"> 4: aload_0</div><div class="line"> 5: invokevirtual #3 // Method wrapItUp:()V</div><div class="line"> 8: return</div><div class="line"> 9: astore_1</div><div class="line">10: aload_0</div><div class="line">11: invokevirtual #3 // Method wrapItUp:()V</div><div class="line">14: aload_1</div><div class="line">15: athrow</div></pre></td></tr></table></figure>
<p>可以看出finally块的代码仍然被放到了return之前。</p>
<blockquote>
<p>如果try块中有return statement，一定是finally中的代码先执行，然后return。</p>
</blockquote>
<p>JVM规范是这么说的：</p>
<blockquote>
<p>Compilation of a try-finally statement is similar to that of try-catch. Pior to transferring control outside thetry statement, whether that transfer is normal or abrupt, because an exception has been thrown, thefinally clause must first be execute.<br>try - catch - finally</p>
</blockquote>
<p>给上面的代码加一个catch块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryCatchFinally</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    tryItOut();</div><div class="line">  &#125; <span class="keyword">catch</span> (TestExc e) &#123;</div><div class="line">    handleExc(e);</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    wrapItUp();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>javap一下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public void tryCatchFinally();</div><div class="line">  Code:</div><div class="line">     0: aload_0</div><div class="line">     1: invokevirtual #2</div><div class="line">     4: aload_0</div><div class="line">     5: invokevirtual #3</div><div class="line">     8: goto          31</div><div class="line">    11: astore_1</div><div class="line">    12: aload_0</div><div class="line">    13: aload_1</div><div class="line">    14: invokevirtual #5                  </div><div class="line">    17: aload_0</div><div class="line">    18: invokevirtual #3</div><div class="line">    21: goto          31</div><div class="line">    24: astore_2</div><div class="line">    25: aload_0</div><div class="line">    26: invokevirtual #3</div><div class="line">    29: aload_2</div><div class="line">    30: athrow</div><div class="line">    31: return</div><div class="line">Exception table:</div><div class="line">   from    to  target type</div><div class="line">       0     4    11   Class TestExc</div><div class="line">       0     4    24   any</div><div class="line">      11    17    24   any</div></pre></td></tr></table></figure>
<p>通过Exception table可以看出：</p>
<ul>
<li>catch监听 0 ~ 4 字节类型为TextExc的异常。</li>
<li>finally为 0 ~ 4 以及 11 ~ 17 字节任何类型的异常。</li>
</ul>
<p>也就说 catch block 本身也在 finally block 的管辖范围之内。如果catch block 中有 return statement，那么也一定是在 finally block 之后执行。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-08-19T16:00:00.000Z"><a href="/2014/08/20/something-about-closure/">2014-08-20</a></time>
      
      
  
    <h1 class="title"><a href="/2014/08/20/something-about-closure/">关于闭包</a></h1>
  

    </header>
    <div class="entry">
      
        <p>先来看一个问题：</p>
<blockquote>
<p>为什么内部类（inner class）用到的外部变量只能是final类型？</p>
</blockquote>
<p>例如以下代码中变量 x 为什么必须声明为 <code>final</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> x = args.length;</div><div class="line">    <span class="keyword">new</span> Thread() &#123;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(x);</div><div class="line">      &#125;</div><div class="line">    &#125;.start();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果去掉 final 关键字，编译阶段就会报错：</p>
<pre>
Closure.java:6: local variable x is accessed from within inner class; needs to be declared final
        System.out.println(x);
                           ^
1 error
</pre>

<p>Java编程思想 中虽然提到了这个规则，但也没有说明为什么。</p>
<blockquote>
<p>If you’re defining an anonymous inner class and want to use an object that’s defined outside the anonymous inner class, the compiler requires that the argument reference be final.</p>
</blockquote>
<p>JLS 8.1.3 中对此的说明：</p>
<blockquote>
<p>Any local variable, formal method parameter or exception handler parameter used but not declared in an inner class must be declared final. Any local variable, used but not declared in an inner class must be definitely assigned before the body of the inner class.*</p>
</blockquote>
<p>但是为什么会有这样的语法规则呢？</p>
<p>其中这就是 Java 中的闭包（Closure），虽然它不是严格意义上的闭包。</p>
<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>引用 wikipedia 的定义：</p>
<blockquote>
<p>In programming languages, a closure (also lexical closure or function closure) is a function or reference to a function together with a referencing environment—a table storing a reference to each of the non-local variables (also called free variables or upvalues) of that function.A closure—unlike a plain function pointer—allows a function to access those non-local variables even when invoked outside its immediate lexical scope.*</p>
</blockquote>
<p>简而言之</p>
<blockquote>
<p>闭包就是一个带数据的函数，这个函数有一个函数环境，环境内包含了函数所用到的非本地变量。</p>
</blockquote>
<p>下面以python代码为例，演示闭包的用法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">maker</span><span class="params">(N)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span><span class="params">(X)</span>:</span></div><div class="line">        <span class="keyword">return</span> X \*\* N</div><div class="line">    <span class="keyword">return</span> action</div></pre></td></tr></table></figure>
<p><code>maker</code> 函数返回了一个嵌套函数（Nested Function）<code>action</code>，其中 <code>action</code> 用到了 <code>maker</code> 的变量 <code>N</code>。</p>
<p>执行一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">f = maker(<span class="number">2</span>)</div><div class="line">print(f)</div></pre></td></tr></table></figure>
<p>结果为</p>
<pre>
<function maker.<locals="">;.action at x7ff257b62950>*
</function></pre>

<p>可以看出 <code>f</code> 是函数 <code>maker</code> 的一个 local 函数 —- <code>action</code><br><code>f = maker(2)</code> 返回之后，<code>maker</code> 的生命周期也结束了，按道理它的 local 变量N，也应该会被释放掉，但是当我们执行如下语句时</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">print(f(<span class="number">3</span>))</div><div class="line">print(f(<span class="number">4</span>))</div></pre></td></tr></table></figure>
<p>返回值为</p>
<pre>
9
16
</pre>

<p>也就是说，即使maker函数的生命周期已经结束，但是action仍然记住了它所用到的maker的局部变量N。<br>在这里，f就是一个闭包，它包含的不仅是action函数，还有action用到的数据 —- a table storing a reference to each of the non-local variables (also called free variables or upvalues) of that function</p>
<p>如果使用 lambda 表达式，上面的 maker 可以修改为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">maker</span><span class="params">(N)</span>:</span></div><div class="line">	<span class="keyword">return</span> <span class="keyword">lambda</span> x: x ** N</div></pre></td></tr></table></figure>
<p>以上就是 Python 中闭包的用法，但是以上用法在 Java 根本无法实现，因为 Java 是一个面向对象的语言，不可能返回一个函数，那么 Java 语言中对闭包又是如何处理的呢？</p>
<h2 id="闭包跟对象的区别"><a href="#闭包跟对象的区别" class="headerlink" title="闭包跟对象的区别"></a>闭包跟对象的区别</h2><p>《こーどの未来》中解释了两者的区别。</p>
<blockquote>
<p>「手続き（関数）とデータの一体化」というのは、オブジェクト指向のオブジェクトを形容するときによく用いられる表現です。オブジェクトはデータにメソッドという形で手続きが内包されているものですが、クロージャーは手続きに環境という形でデータが内包されています。つまり、オブジェクトとクロージャーは表裏一体と考えてもよいでしょう</p>
</blockquote>
<p>稍微总结以下：</p>
<blockquote>
<p>对象是在数据的基础上，以方法的形式把函数包含在内。<br>闭包是在函数的基础上，以环境的形式把数据包含在内。</p>
</blockquote>
<h2 id="Java-与闭包"><a href="#Java-与闭包" class="headerlink" title="Java 与闭包"></a>Java 与闭包</h2><p>通过 Python 语言的示例，可以比较容易得理解闭包与对象之间的区别，我们再来看一下文章开头提出的问题。</p>
<p>为什么内部类（inner class）用到的外部变量只能是final类型 ？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> x = args.length;</div><div class="line">    <span class="keyword">new</span> Thread() &#123;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(x);</div><div class="line">      &#125;</div><div class="line">    &#125;.start();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实，编译器为 <code>Thread()</code> 匿名类自动添加了一个参数为 <code>int</code> 的构造函数，在新建 <code>Thread</code> 对象时，<code>x</code> 值被传入，成为 <code>Thread</code> 对象的数据。如此以来，编译器则没有必要像 python 那样为 <code>inner class</code> 维护一个 <em>referencing environment</em>。</p>
<p>我们可以用一段代码把这个构造函数找出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> x = args.length;</div><div class="line">    <span class="keyword">new</span> Thread() &#123;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(x);</div><div class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; cons : <span class="keyword">this</span>.getClass().getDeclaredConstructors()) &#123;</div><div class="line">          StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">          sb.append(<span class="string">"constructor: "</span>).append(cons.getName()).append(<span class="string">"("</span>);</div><div class="line">          <span class="keyword">for</span> (Class&lt;?&gt; param : cons.getParameterTypes()) &#123;</div><div class="line">            sb.append(param.getSimpleName()).append(<span class="string">", "</span>);</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">if</span> (sb.charAt(sb.length() - <span class="number">1</span>) == <span class="string">' '</span>) &#123;</div><div class="line">            sb.replace(sb.length() - <span class="number">2</span>, sb.length(), <span class="string">")"</span>);</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">            sb.append(<span class="string">')'</span>);</div><div class="line">          &#125;</div><div class="line">          System.out.println(sb);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;.start();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果是</p>
<pre>
0
constructor: Closure$1(int)
constructor: Closure$1(int) 即为编译器添加的构造方法。
</pre>

<p>x 就是通过这个构造函数拷贝到内部类 - <code>new Thread()</code> 当中，但是用到 x 的方法 run 并不会按照代码顺心立即被执行，如果在 <code>new Thread()</code> 之后的代码中改变了 x 的值，那么多 run 方法中用到的 x 就是一个过时（out-of-date）的 x。</p>
<p>同样的，如果run方法改变了 x 的值就破坏了 main 方法的数据流，我们希望内部类对使用者来说是透明，加上了 final 关键字就保证了 x 只在方法的 enclosing scope 是可变的,这样就不必为了追踪 x 的变化而必须搞清楚内部类的逻辑。</p>
<p>StackOverflow 上Jon Skeet 解释得非常清楚。</p>
<blockquote>
<p>When you create an instance of an anonymous inner class, any variables which are used within that class have their values copied in via the autogenerated constructor. This avoids the compiler having to autogenerate various extra types to hold the logical state of the “local variables”, as for example the C# compiler does… (When C# captures a variable in an anonymous function, it really captures the variable - the closure can update the variable in a way which is seen by the main body of the method, and vice versa.)<br>As the value has been copied into the instance of the anonymous inner class, it would look odd if the variable could be modified by the rest of the method - you could have code which appeared to be working with an out-of-date variable (because that’s effectively what would be happening… you’d be working with a copy taken at a different time). Likewise if you could make changes within the anonymous inner class, developers might expect those changes to be visible within the body of the enclosing method.<br>Making the variable final removes all these possibilities - as the value can’t be changed at all, you don’t need to worry about whether such changes will be visible. The only ways to allow the method and the anonymous inner class see each other’s changes is to use a mutable type of some description. This could be the enclosing class itself, an array, a mutable wrapper type… anything like that. Basically it’s a bit like communicating between one method and another: changes made to the parameters of one method aren’t seen by its caller, but changes made to the objects referred to by the parameters are seen.</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Closure 是 Functional Programming（函数式编程）中一个非常重要的概念，理解了闭包的概念也就知道 lambda 以及 nested function 的用法了。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-07-09T16:00:00.000Z"><a href="/2014/07/10/four-anniversary-after-graduation/">2014-07-10</a></time>
      
      
  
    <h1 class="title"><a href="/2014/07/10/four-anniversary-after-graduation/">毕业四年了</a></h1>
  

    </header>
    <div class="entry">
      
        <p>2010年6月底，终于本科毕业进入职场，那时的我“很傻很天真”，不畏惧将来，不惧怕权贵，如假包换的“愣头青”一枚。顽固、无知、浮躁，是现在的我给4年前的我贴上的标签。</p>
<p>2014年7月，本科毕业四周年，职场混迹三年，海外生活一年，站在今天回首过去，发现走了很多弯路，究其原因，个人占7成，环境占3成。</p>
<h2 id="我与日语"><a href="#我与日语" class="headerlink" title="我与日语"></a>我与日语</h2><p>刚毕业那会，误打误撞进入日企，从此与日语结下不解之缘，一口气考到日语最高等级JLPT-N1，然后辞职去日本游学一年，口语如今也说得过去，读日文原版书也毫无压力。现在终于下定决心，离开日语圈子，一心一意搞我钟爱的编程。从今以后，日语可能只是一个兴趣爱好了，与工作不再相关，为了与它道别，再次参加了JLPT-N1的考试，不论考试结果如何，这是一场告别战。(最终成绩 161分)</p>
<blockquote>
<p>さようなら、日本語。</p>
</blockquote>
<h2 id="我与编程语言"><a href="#我与编程语言" class="headerlink" title="我与编程语言"></a>我与编程语言</h2><p>大学期间疯狂参加各种比赛，什么数学趣味知识大赛，算法比赛，数学建模，能参加的都参加了。非常遗憾的是，没有进一步深入，一方面是因为当时大学校园里没有参加ACM和topcoder的氛围，另一方面也因为个人眼光太狭隘，只局限于周围的人，没有能里跳出这个圈子。而且大学期间本能地很排斥java，喜欢C++。进而直接导致在MFC上花了过多的时间，甚至工作以后有大概半年多的时间还是在搞这个。<br>现在来看，也许对C++并不是“真爱”，只是当时大家都觉得C++比java难，而我比较喜欢啃硬骨头，所以就开始死嗑C++，无论是简单的字符串处理还是UI，都用它来做，很显然这是相当不明智的做法。</p>
<p>对于当时的项目来说，用C++实在是太麻烦了。因为自动化测试软件本身不追求效率，何不用脚本语言来写，然后就跟当时的一个实习生边学边做，把解析C代码文件的依赖关系、生成makefile的C++代码都用Python重写了，测试用例文件也直接使用python，抛弃之前别人写的测试用例解析器。如此一来测试人员就可以既迅速又自由地测试用例，但是另一面却增加了学习成本，不是每个人都喜欢学习新东西，后来随着我离开项目组去做android开发，推进地也不顺利。</p>
<p>生成测试目标和测试用例的功能全部用Python重写之后，接下来的一个重点就是软件UI了，那个时候我们用的还是XP系统，win7没出，vista没人用。提到windows上的UI，当然不能再搞MFC了，因为再搞下去会没完没了，于是选择了基于C#的框架WPF，那个时候我坚信，随着微软跟诺基亚的强强结合，WP肯定会大卖，这样我们就可以无缝迁移到手机端了，现在来看，一句话：</p>
<blockquote>
<p>あまかった　Naive</p>
</blockquote>
<p>这个项目做的很失败，一个主要原因就是我对采用新技术开发的风险预估不够，搞的大家都很累，好歹最后还是完成了。后来读了《人月神话》才知道，其实是陷入了二次系统的泥潭。<br>领导成功地把这个项目申请为公司的自主项目，项目企划书上写的人员配置与真实情况大相径庭，实际上是我一个人带三个实习生，加起来也不过1.6个人，更何况那时候才刚进公司一年不到，工资比较低，所以实际花费肯定低于1.6。以至于后面的大部分工作都是在做文档、整理数据、控制进度、安排工作。本来这个项目的1.0版本是通过日本客户付给我们钱做出来的，如果转化为公司的自主项目必然要跟日方客户谈清楚各自所占的百分比。从个人角度来看，领导不敢去谈，因为这会损害与客户之间的关系。我当时也已经快受不了整天加班整理文档的琐碎工作，于是把当前的状况跟他仔细谈了一下，并希望领导给我们配一个编程能力不错的正式员工。<br>可是，第二天领导把我喊到会议室，突然告诉我，这个项目他不打算做了，让我去做其他事情。最后他一个人参加了这个项目的最后一次自主项目会议（没让我参加，之前一直都是我们共同参加的）。不知道他是怎么跟总经理汇报的，结果就是这个项目的自主产品之路就结束了。</p>
<p>当时公司正在接日本富士通的android开发业务，我也从2012年1月1日开始正式转到其他部门，开始了android之旅。一开始对android开发真是一窍不通，凭借扎实的C++功底，把android的四大components - Activity Service Receiver ContentProvider弄清楚之后，很快就上手了，我负责的功能模块整体来看比较简单（当然了，整个team都是UI开发），由于那时日语已经过了N1，所以做为sub-leader一边跟日本客户沟通，一边带着其他三个人一起写代码。这个项目几乎天天加班，不分昼夜，也不分周末，一周通宵三次的情况也时有发生，高峰时期有30个人一起开发，由于前期架构的失败，导致大量的重复代码，垃圾代码，到了后期bug迭出，近乎失控。就这样项目一直延期到7月份才结束。其实《人月神话》中也讲到，</p>
<blockquote>
<p>向一个已经延期的项目中增加更多的人手，只会导致项目更加延迟，因为沟通成本会急剧上升</p>
</blockquote>
<p>一直以来我都想做一些比较难的东西，可惜这两个项目都无法看到希望，我记得网上看过一句名言：</p>
<blockquote>
<p>判断应不应该在一个公司继续待下去的一个标准就是看看周围工作年限比你长的人，你是否也想成为这样的人。</p>
</blockquote>
<p>我不想成为那样的人，于是下定决心去日本留学深造，8月份离职，去新东方学了一下TOEFL，凑够了学费，2012年10月，登上了飞往日本的飞机。坐在飞机上，看着陆地上的房子变得越来越小、越来越小，心中思绪万千，将来的我会在哪里，一切都是未知数。</p>
<p>在日本这一年，深深地喜欢上了自然语言处理（NLP），因为本身对自然语言的兴趣，掌握中文、日文、英文三国语言，再加上计算机知识，应该很easy，就把《Natural Language Processing with Python》前后读了两遍，代码照着敲了一遍，后面又看了几本日语版的介绍NLP的书，仍然不得要领。后来读了《数学之美》我才发现我又あまい了，因为现在的自然语言处理所用的方法是基于统计的，基于规则的方法已经不在适用。所以，我觉得：</p>
<blockquote>
<p>自然语言处理重点不在自然语言，而是处理。</p>
</blockquote>
<p>不过这个学习过程倒是让我的Python编程能力提升了不少。</p>
<p>当决定回国时，重新规划了自己的职业生涯，萌生了一个新的想法，天真地以为对日外包也好，产品研发也好，都是不同的行业，只要充分发挥自己的能力，一样可以成为一个行业的佼佼者。</p>
<p>2013年10月，又回到了原先的公司，作为leader，继续做富士通手机的Android应用开发，每天跟日方客户开会、讨论，就这样也忙得不亦乐乎，直到去北京参加了一次 MDCC 2014大会，在会场买了一本《淘宝技术这十年》，读罢此书后让我明白:</p>
<blockquote>
<p>无论你做任何行业，不要忽略了兴趣，那才是你最大的动力</p>
</blockquote>
<p>所以，不能忽略兴趣，我要继续专心搞技术。<br>四年了，写了不少代码，也读了不少书，可惜这四年没有始终保持一条技术主线，总是走过一段路后就叉到其路上。<br>看着开源社区的大牛们所写的代码，惭愧汗颜。想成为大牛，就必须改变现状，朝着目标前进！</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>






<nav id="pagination">
  
    <a href="/page/6/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/8/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:liangfei.me">
  </form>
</div>

  

  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Git/" style="font-size: 12.5px;">Git</a> <a href="/tags/Gradle/" style="font-size: 10px;">Gradle</a> <a href="/tags/Hybrid/" style="font-size: 10px;">Hybrid</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Retrofit/" style="font-size: 12.5px;">Retrofit</a> <a href="/tags/RxJava/" style="font-size: 10px;">RxJava</a> <a href="/tags/Web/" style="font-size: 12.5px;">Web</a> <a href="/tags/dart/" style="font-size: 10px;">dart</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/iOS/" style="font-size: 10px;">iOS</a> <a href="/tags/个人总结/" style="font-size: 17.5px;">个人总结</a> <a href="/tags/产品设计/" style="font-size: 10px;">产品设计</a> <a href="/tags/单元测试/" style="font-size: 10px;">单元测试</a> <a href="/tags/汽车/" style="font-size: 10px;">汽车</a> <a href="/tags/移动开发/" style="font-size: 10px;">移动开发</a>
  </div>
</div>


  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2017/07/04/2017-semi-annual-summary/">2017 年中总结</a>
      </li>
    
      <li>
        <a href="/2017/03/21/app-force-update-architecture/">Android 强升逻辑和实现</a>
      </li>
    
      <li>
        <a href="/2017/02/15/2016-summary/">2016 年终总结</a>
      </li>
    
      <li>
        <a href="/2017/02/04/thinking-in-mobile/">关于 App 开发的一些思考</a>
      </li>
    
      <li>
        <a href="/2017/02/01/note-on-web-data-analysis/">架构笔记之数据分析</a>
      </li>
    
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2017 liangfei
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
var disqus_shortname = 'liangfeizc';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>